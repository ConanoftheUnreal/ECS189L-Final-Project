# Seth Sjoberg
sasjoberg@ucdavis.edu

## Main Role: Animation & Visuals
I greatly enjoyed learning the basics of animation in Unity. This was my first time programming animations at a large scale, so I am very thankful that there is such a large community of Unity developers on the internet. Particularly, YouTube was a great help here. Having delved a bit deeper on our class' Exercise 1, I noticed the basics of how Unity handles animation with its Animator component and the Finite State Machine one creates to handle where and when animations play. But when researching for this project, I happened upon a YouTube video that explained how to avoid the confusing web that can be a consequence of making an FSM, [by using a blend tree](https://www.youtube.com/watch?v=S3ys0jCUE9s) for one's animations. This turned out to be a blessing and a curse (more on this later).

As for the images to animate, we used many different free and publically available assets from the site itch.io:
- All Player, Enemy, Items, & Tilesets from the [Lucifer Collection](https://itch.io/c/1557879/lucifer)
- [Fireballs](https://xyezawr.itch.io/gif-free-pixel-effects-pack-6-forks-of-flame)
- [Pop Effect](https://nyknck.itch.io/fx071)
- [Combustion Effect](https://brullov.itch.io/fire-animation)
- [Dash Effect](https://nyknck.itch.io/pixel-art-effect-fx033)
- [Blood Effect](https://nyknck.itch.io/bloodfx)

Once the collection of sprites were found that matched the design style of our game, the sprites were all spliced within the Unity editor, and used to create animation clips. These clips are called upon within scripts such as [PlayerAnimationController.cs](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Player/PlayerAnimationController.cs), [EnemyAnimation.cs](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Enemy/EnemyAnimation.cs), and [AnimatingObject.cs](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/AnimatingObject.cs), most of which I structured with the ideas borrowed from the blend tree idea along with other desired functionality. This additional functionality was very fun to implement; these were ideas I came up with, implemented, and got only positive reaction when showcasing them to both my project teammates and the class during our convention. Their purposes are all game feel oriented to create a dynamic, interactive, impactful world that augments one's interest and continually grabs the player's attention:
- [Blood Effect upon last hit](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Player/PlayerAnimationController.cs#L139)
- Slowed Player death for dramatic effect (sprite placement stretched within animation clip itself)
- [Cloud of smoke upon destruction of Enemies](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/AttackableController.cs#L140)
- [Animating collectibles at slightly different speeds for a dynamic world](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/AnimatingObject.cs#L9)
- [Wind Effect upon Player dash](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Player/PlayerAnimationController.cs#L282)
- [I-Frame blinking after hit](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Player/PlayerAnimationController.cs#L98)
- [Dissipation of fireball for Sorceress](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Player/PlayerAttackController.cs#L130)
- Combustion of fireball upon impact with something **
- Pop of enemy arrows upon impact with something **

** [These use the same logic](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Player/ProjectileScript.cs#L46)

Other important features such as tying the Player speed stat to the animator's speed were very helpful in creating visually appealing movement, as well as increasing functionality of gameplay; the Player attacks slightly faster per speed stat upgrade, as well as runs more quickly, both of which can be seen in the speed of the Player sprite during animation.

Any and all difficulties faced in the production of these animations was related to the learning curve in how Unity handled certain pieces of data. One such difficulty (the curse of the blend tree mentioned previously) is the issue of having multiple animations play at one point in time. This is the very idea of what makes a blend tree, but having not researched this enough until after beginning my implementation, I believed the motion field structure visible in the blend trees for each humanoid's animator was picking which animation to play based off of the Euclidean distance of the MoveX and MoveY parameters provided by my scripts from the coordinates of each animation queue in the field; I was under the assumption that it would only play the closest animation, and this is only partly true. For 2D animation, it appears Unity does choose the closest queue for which animation clip to make visible on the screen, but it actually loads both animations in memory, meaning any and all animation events (functions called at certain points in the animation) get played by all animation clips that Unity deemed had input close enough and would then "blend" said animation clips. Blending is clearly much more useful in 3D applications, though I was unaware of this and created an used an easy method of implementing movement at the cost of creating large difficulties in extra function calls that were annoying to debug and of which those fixes are valid but undesirable to begin with. If I could start developing this game again from scratch, I would have opted for the chaotic web of an animator FSM for the usefulness of animation events over the ease of blend trees with duct tape fixes for double function calls (unfortunately, it was too close to the deliverable date to scrap what we had by the time the bugs were discovered).

It was an extremely educational experience working on the animations for this game, not to mention very fun getting to immediately interact with one's work upon loading the game. This role was actually dropped on my lap due to the business of my quarter that I couldn't meet with the team during one of our early group discussions. But I suppose I have only good things to say for the chance to do Animation and Visuals, as I had a grand time developing part of what lets the world come to life.

## Subrole: Player & Enemy Movement
I adopted part of the development for Player & Enemy Movement at the time I realized I wanted a way to test if the animations I had produced were working properly. This included the updating and maintenence of [PlayerMovement.cs](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Player/PlayerMovement.cs) as well as the implementation of [EnemyMovement.cs](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Enemy/EnemyMovement.cs). Fortunately, much of the work on these two scripts were either a group effort or were made significantly easier by construction of other mechanics of the game. An example of this can be seen in EnemyMovement.cs where the FixedUpdate function simply accesses two pieces of data to send the enemy where they need to go, the `movementDirection` from Brad's use of Polarith AI and a `statelock` variable from my own PlayerAnimationController.cs.

The only particularly interesting concepts of the Player and Enemy movement is the dash mechanic for the player and the knock back upon being damaged. The implementation for these two ideas is simple, starting with [knock back](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Enemy/EnemyMovement.cs#L24): a reasonable vector is determined from the damaging object or a related entity to the damaged entity, towards which the damaged entity will be pushed. If the enemy is the damaged entity, the attack level of the Player is taken into account as well as whether a projectile was used (projectiles push the body less than a sword, but it's also for balance of close and long range battling). And then there is the dash mechanic: dashing is the idea that the player is dodging. It is a moment in time in which the player is invulerable to damage due to the fact that when the player is dashing, the damage function handled in PlayerAnimationController.cs (a bit of a weird spot, but this script is more like "PlayerAnimationAndInteraction.cs", but that is rather long) [simply returns](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Player/PlayerAnimationController.cs#L122) as opposed to registering the hit, decreasing health, and playing the proper animation. The trail effect is actually just a gameobject used with an AnimatingObject component for ease. The only side effect of not using Unity's particle system or something similar is the rigid angle of the sprite you can see sometimes when dashing and turning quickly. I considered this a rather small artifact, and the other guys didn't seem to care, so we've kept it as is.

Helping with Player & Enemy Movement was enjoyable, and I appreciate that no one got worked up over the need for our subroles to expand and alter rather fluidly sometimes. This attitude is what allowed us to accomplish the amount we did in the time we had.

## Subrole: Combative Interaction
Combat is a natural consequence of the style of game we planned to make. Being a roguelite, it is the core gameplay experience to try and push your way through the level, hoping to survive until the end. Brad was handling the Enemy AI, though it was around when he had finished developing the main structure for that component when I realized that we had no interaction actually implemented for the player and enemy. This is why I took up the subrole of what I call Comabtive Interaction, as we wanted to make sure there was something to do when the player and enemy finally found themselves in front of each other!

The logic for this interaction is handled within the four scripts [PlayerAttackController.cs](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Player/PlayerAttackController.cs), [AttackableController.cs](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/AttackableController.cs), [EnemyAttackController.cs](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Enemy/EnemyAttackController.cs), and [EnemyAttackSprite.cs](https://github.com/ConanoftheUnreal/ECS189L-Final-Project/blob/main/Lucifer's%20Trials/Assets/Scripts/Enemy/EnemyAttackSprite.cs). The main ideas behind how these scripts interact is through enabling and disabling "attack sprites" and checking for collision of an entity with said sprites. Attack sprites are child gameobjects of the Player and of each type of Enemy. These objects define the region in front of them in which an attack would collide with an entity standing in their path. There is an attack sprite for the four cardinal directions, and the Player and Enemy use different attack sprites that better fit the area of attack their weapons cover (Note that technically the Enemy "Slingers" never actives its attack sprites as it fires a projectile instead; I was planning to perhaps change this so that slingers would CQC if the player were close enough, but time constraints said no, and they're also already a difficult enemy to fight). Collision was handled with Collider components acting as triggers. The attack sprites are invisible game objects (sprite renderer is turned off), allowing the slash depicted in the animations themselves to feel more accurate to the damaging region, and the sprite shapes themselves were also modeled so that these slashes decently represent where one can hit or be hit by a given attack.

Handling the interaction of Player and Enemy in the combat scenario was rather fun, as it asked for A LOT of play testing (and who doesn't like playing games?). It was always fun to realize something could be bettered, implement it, and then test it to see that the gameplay was evolving into a smoother and more enjoyable experience. I am happy to have taken up this role, as I think it turned out nicely.

## Subrole: Game Feel
Many things I implemented for my main role of Animation & Visuals was from the point of view of a player. Would fireballs combusting on impact look good? Are the feet hitting the ground at the proper time? Should I add another effect on top of all those other ones just because I think it would look nice? The answer either was or was made to be "yes" for all of those and more. I came to realize that I was naturally falling into the role of Game Feel by the simple fact that I wanted the game to feel great! I hadn't even spoken with anyone else about Game Feel by the time many of my additions had been implemented. So when I finally saw that this was important to me, I began working with Brad and Steven to conversate about what would go well where and when. It became a very common occurrence, and I appreciate the receptiveness of the two in allowing my voice to be heard in this domain. An example were the several times that I requested a sound from Steven (explosion for fire combustion, foot steps for humanoids, growl for enemies during attack, etc.), and he always got back to me ready to make or find something that would work. It was a joy working with the two to bring liveliness to our little world.

## Subrole: Narrative
Unfortunately, we did not have the time to flesh out the game enough that a narrative felt neccesary. Hence, one does not exist! As seen above, my time was self allocated to more pressing matters at the time of development, such as more and better visuals (main role), Player & Enemy Movement, and Combat; each of these roles were inadequate at the time I had fully developed all basic animations, so I took over these roles so that the game would be reasonably finished by the expected due date. It was fun working on these subroles, as they are both logic that is immediately visible upon interacting with the world, an aspect I love about developing games.